<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Rhythm Game</title>
<style>
  :root{--bg:#111;--lane:#222;--note:#2ee;--hit:#2f2;--miss:#e33;color:#eee}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--color);font-family:Arial,Helvetica,sans-serif}
  .game{width:800px;margin:20px auto;text-align:center}
  .stage{position:relative;height:480px;background:linear-gradient(180deg,#0000 0,#0003),#0b0b0b;border-radius:8px;overflow:hidden}
  .lanes{position:absolute;left:50%;transform:translateX(-50%);bottom:0;height:100%;width:320px;display:flex;justify-content:space-between;padding:20px}
  .lane{width:72px;height:100%;background:linear-gradient(#222,#111);border-radius:8px;box-shadow:inset 0 6px 0 #0005}
  .target{position:absolute;left:50%;transform:translateX(-50%);bottom:60px;width:320px;height:8px;background:rgba(255,255,255,0.03);pointer-events:none}
  .note{position:absolute;width:64px;height:32px;background:var(--note);left:0;border-radius:6px;box-shadow:0 4px 8px #0006;display:flex;align-items:center;justify-content:center;color:#012;font-weight:700}
  .hud{display:flex;justify-content:space-between;align-items:center;padding:10px 0;color:var(--color)}
  .score{font-size:18px}
  .feedback{position:absolute;left:50%;transform:translateX(-50%);top:20px;font-size:20px}
</style>
</head>
<body>
<div class="game">
  <h2>Mini Rhythm Game — аналог</h2>
  <div class="hud"><div class="score">Score: <span id="score">0</span></div><div>Use ← ↑ ↓ →</div></div>
  <div class="stage" id="stage">
    <div class="target"></div>
    <div class="lanes" id="lanes">
      <div class="lane" data-key="ArrowLeft"></div>
      <div class="lane" data-key="ArrowUp"></div>
      <div class="lane" data-key="ArrowDown"></div>
      <div class="lane" data-key="ArrowRight"></div>
    </div>
    <div class="feedback" id="feedback"></div>
  </div>
  <p style="font-size:13px;color:#bbb">Просто пример — замени звук/арт и добавь тайминги</p>
</div>

<script>
/* Простая ритм-логика */
const lanes = Array.from(document.querySelectorAll('.lane'));
const stage = document.getElementById('stage');
const scoreEl = document.getElementById('score');
const feedback = document.getElementById('feedback');

const laneCount = lanes.length;
const laneWidth = 80;
const spawnX = (stage.clientWidth - 320)/2 + 20; // not used precisely
let notes = [];
let score = 0;
let startTime = null;
let bpm = 90;
let beatInterval = 60000 / bpm; // ms per beat

// Example timeline: array of {time(ms), laneIndex}
const timeline = [
  1000, 1500, 2000, 2500, 3000, 3600, 4200, 4800
].map((t,i)=>({time:t, lane: i % laneCount}));

function spawnNote(laneIndex){
  const laneEl = lanes[laneIndex];
  const rect = laneEl.getBoundingClientRect();
  const globalRect = stage.getBoundingClientRect();
  const note = document.createElement('div');
  note.className = 'note';
  note.textContent = ['←','↑','↓','→'][laneIndex];
  const x = laneEl.offsetLeft + (laneEl.clientWidth - 64)/2;
  note.style.left = x + 'px';
  note.style.bottom = '520px'; // start above
  stage.appendChild(note);
  notes.push({el:note,lane:laneIndex,spawn:performance.now()});
}

function update(now){
  if (!startTime) startTime = now;
  const t = now - startTime;

  // spawn based on timeline
  while(timeline.length && timeline[0].time <= t + 1000){ // spawn 1s early
    const ev = timeline.shift();
    spawnNote(ev.lane);
  }

  // move notes downward
  for (let i = notes.length-1;i>=0;i--){
    const n = notes[i];
    const dt = now - n.spawn;
    // travel 1s from spawn to target area (bottom ~60px)
    const total = 2000; // ms to reach target
    const progress = dt / total;
    const startY = 520;
    const endY = 60;
    const y = startY + (endY - startY) * progress;
    n.el.style.bottom = y + 'px';
    if (progress >= 1.2){ // missed and passed
      stage.removeChild(n.el);
      notes.splice(i,1);
      showFeedback('MISS','#e33');
    }
  }

  requestAnimationFrame(update);
}

function showFeedback(text,color){
  feedback.textContent = text;
  feedback.style.color = color;
  setTimeout(()=>{ if (feedback.textContent===text) feedback.textContent=''; },400);
}

window.addEventListener('keydown',(e)=>{
  const key = e.key;
  const laneIndex = ['ArrowLeft','ArrowUp','ArrowDown','ArrowRight'].indexOf(key);
  if (laneIndex === -1) return;
  // find nearest note in lane
  let bestIdx = -1;
  let bestDist = 1e9;
  for (let i=0;i<notes.length;i++){
    const n = notes[i];
    if (n.lane !== laneIndex) continue;
    const bottom = parseFloat(n.el.style.bottom);
    const dist = Math.abs(bottom - 60);
    if (dist < bestDist){ bestDist = dist; bestIdx = i; }
  }
  if (bestIdx === -1){
    showFeedback('MISS','#e33');
    return;
  }
  const n = notes[bestIdx];
  if (bestDist < 18){
    score += 300;
    showFeedback('PERFECT','#2f2');
  } else if (bestDist < 40){
    score += 100;
    showFeedback('GOOD','#ffb86b');
  } else {
    score += 0;
    showFeedback('MISS','#e33');
  }
  scoreEl.textContent = score;
  // remove hit note
  stage.removeChild(n.el);
  notes.splice(bestIdx,1);
});

requestAnimationFrame(update);
</script>
</body>
</html>
